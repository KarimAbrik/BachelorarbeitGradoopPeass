/**
 * Test grouping using the {@link TimeStampKeyFunction} key function.
 *
 * @throws Exception when the execution in Flink fails
 */
@Test
public void testTimeStampKeyFunctionOnGraph() throws Exception {
    final long testTime1 = asMillis("2019.01.01 01:00:00.000");
    final long testTime2 = asMillis("2019.01.01 01:00:00.001");
    final long testTime3 = asMillis("2018.01.01 01:00:00.000");
    final long testTime4 = asMillis("2019.02.01 01:00:00.000");
    FlinkAsciiGraphLoader loader = getLoaderFromString("input[" + "(:t {__valFrom: " + testTime1 + "L, __valTo: " + testTime2 + "L, a: 1L})" + "(:t {__valFrom: " + testTime1 + "L, __valTo: " + testTime2 + "L, a: 2L})" + "(:t {__valFrom: " + testTime2 + "L, __valTo: " + testTime2 + "L, a: 3L})" + "(:t {__valFrom: " + testTime2 + "L, __valTo: " + testTime2 + "L, a: 4L})" + "(:t {__valFrom: " + testTime3 + "L, __valTo: " + testTime4 + "L, a: 5L})" + "(:t {__valFrom: " + testTime3 + "L, __valTo: " + testTime4 + "L, a: 6L})" + "(:t {__valFrom: " + testTime4 + "L, __valTo: " + testTime4 + "L, a: 7L})" + "(:t {__valFrom: " + testTime4 + "L, __valTo: " + testTime4 + "L, a: 8L})" + "] expected1 [" + "({time_VALID_TIME_FROM: " + testTime1 + "L, min_a: 1L, max_a: 2L, count: 2L})" + "({time_VALID_TIME_FROM: " + testTime2 + "L, min_a: 3L, max_a: 4L, count: 2L})" + "({time_VALID_TIME_FROM: " + testTime3 + "L, min_a: 5L, max_a: 6L, count: 2L})" + "({time_VALID_TIME_FROM: " + testTime4 + "L, min_a: 7L, max_a: 8L, count: 2L})" + "] expected2 [" + "({time_VALID_TIME_FROM_MonthOfYear: 1L, time_VALID_TIME_FROM_Year: 2019L," + " min_a: 1L, max_a: 4L, count: 4L})" + "({time_VALID_TIME_FROM_MonthOfYear: 1L, time_VALID_TIME_FROM_Year: 2018L," + " min_a: 5L, max_a: 6L, count: 2L})" + "({time_VALID_TIME_FROM_MonthOfYear: 2L, time_VALID_TIME_FROM_Year: 2019L," + " min_a: 7L, max_a: 8L, count: 2L})" + "] expected3 [" + "({time_VALID_TIME_TO_MilliOfSecond: 1L, min_a: 1L, max_a: 4L, count: 4L})" + "({time_VALID_TIME_TO_MilliOfSecond: 0L, min_a: 5L, max_a: 8L, count: 4L})" + "]");
    List<AggregateFunction> vertexAggregateFunctions = Arrays.asList(new MaxVertexProperty("a", "max_a"), new MinVertexProperty("a", "min_a"), new VertexCount("count"));
    TemporalGraph input = toTemporalGraphWithDefaultExtractors(loader.getLogicalGraphByVariable("input"));
    // Test with no TemporalField calculated
    List<KeyFunction<TemporalVertex, ?>> vertexKeysValidFrom = Collections.singletonList(TemporalGroupingKeys.timeStamp(VALID_TIME, FROM));
    TemporalGraph expected1 = toTemporalGraph(loader.getLogicalGraphByVariable("expected1"));
    TemporalGraph result1 = input.callForGraph(new KeyedGrouping<>(vertexKeysValidFrom, vertexAggregateFunctions, Collections.emptyList(), Collections.emptyList()));
    collectAndAssertTrue(result1.toLogicalGraph().equalsByElementData(expected1.toLogicalGraph()));
    // Test with two TemporalFields calculated
    List<KeyFunction<TemporalVertex, ?>> vertexKeysValidFrom2 = Arrays.asList(TemporalGroupingKeys.timeStamp(VALID_TIME, FROM, ChronoField.MONTH_OF_YEAR), TemporalGroupingKeys.timeStamp(VALID_TIME, FROM, ChronoField.YEAR));
    TemporalGraph expected2 = toTemporalGraph(loader.getLogicalGraphByVariable("expected2"));
    TemporalGraph result2 = input.callForGraph(new KeyedGrouping<>(vertexKeysValidFrom2, vertexAggregateFunctions, Collections.emptyList(), Collections.emptyList()));
    collectAndAssertTrue(result2.toLogicalGraph().equalsByElementData(expected2.toLogicalGraph()));
    // Test with validTo time
    List<KeyFunction<TemporalVertex, ?>> vertexKeysValidTo = Collections.singletonList(TemporalGroupingKeys.timeStamp(VALID_TIME, TO, ChronoField.MILLI_OF_SECOND));
    TemporalGraph expected3 = toTemporalGraph(loader.getLogicalGraphByVariable("expected3"));
    TemporalGraph result3 = input.callForGraph(new KeyedGrouping<>(vertexKeysValidTo, vertexAggregateFunctions, Collections.emptyList(), Collections.emptyList()));
    collectAndAssertTrue(result3.toLogicalGraph().equalsByElementData(expected3.toLogicalGraph()));
}