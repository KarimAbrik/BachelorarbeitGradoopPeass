/**
 * Reads the next key/value pair from the input for processing.
 *
 * @param key the new key
 * @param value the new value
 * @return true if a key/value pair was found
 * @throws IOException on failure
 */
private boolean next(LongWritable key, Text value) throws IOException {
    if (fsin.getPos() < end && readUntilMatch(TLFConstants.START_TAG.getBytes(Charsets.UTF_8), false)) {
        try {
            buffer.write(TLFConstants.START_TAG.getBytes(Charsets.UTF_8));
            if (readUntilMatch(TLFConstants.END_TAG.getBytes(Charsets.UTF_8), true)) {
                key.set(fsin.getPos());
                if (fsin.getPos() != end) {
                    //- end tag because it is the new start tag and shall not be added
                    valueLength = buffer.getLength() - TLFConstants.END_TAG.getBytes(Charsets.UTF_8).length;
                } else {
                    // in this case there is no new start tag
                    valueLength = buffer.getLength();
                }
                //- end tag because it is the new start tag and shall not be added
                value.set(buffer.getData(), 0, valueLength);
                //set the buffer to position before end tag of old graph which is
                // start tag of the new one
                fsin.seek(fsin.getPos() - TLFConstants.END_TAG.getBytes(Charsets.UTF_8).length);
                return true;
            }
        } finally {
            buffer.reset();
        }
    }
    return false;
}