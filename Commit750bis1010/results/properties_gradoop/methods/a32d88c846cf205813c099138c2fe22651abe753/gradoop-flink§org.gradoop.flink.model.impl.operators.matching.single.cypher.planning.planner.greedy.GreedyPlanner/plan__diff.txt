/**
 * Computes the {@link PlanTableEntry} that wraps the {@link QueryPlan} with the minimum costs
 * according to the greedy optimization algorithm.
 *
 * @return entry with minimum execution costs
 */
public PlanTableEntry plan() {
    PlanTable planTable = initPlanTable();
    while (planTable.size() > 1) {
        PlanTable newPlans = evaluateJoins(planTable);
        if (newPlans.size() == 0) {
            // No new plans where generated by joining but there are still multiple disconnected
            // query graph components. In this case we need to do a cartesian product.
            newPlans = evaluateCartesianProducts(planTable);
        }
        newPlans = evaluateFilter(newPlans);
        newPlans = evaluateProjection(newPlans);
        // get plan with minimum costs and remove all plans covered by this plan
        PlanTableEntry bestEntry = newPlans.min();
        planTable.removeCoveredBy(bestEntry);
        planTable.add(bestEntry);
    }
    return planTable.get(0);
}