@Test
public void testKeepOnlyRelevantVertices() throws Exception {
    FlinkAsciiGraphLoader loader = getLoaderFromString("source:G {source : \"graph\"}[" + "(a:Patent {author : \"asdf\", year: 2000, title: \"P1\"})-[:cite {difference : 0}]->(b:Patent {author : \"asdf\", year: 2000, title: \"P2\"})" + "(a)-[:cite {difference : 0}]->(c:Patent {author : \"asdf\", year: 2000, title: \"P3\"})" + "(b)-[:cite {difference : 0}]->(c)\n" + "(a)-[:cite {difference : 5}]->(d:Patent {author : \"zxcv\", year: 1995, title: \"Earlier...\"})" + "(b)-[:cite {difference : 5}]->(d)" + "(e:Patent {author : \"kdkdkd\", year: 1997, title: \"Once upon a time\"})-[e_d:cite {difference : 2}]->(d)" + "]");
    GraphCollection sourceGraph = loader.getGraphCollectionByVariables("source");
    // Caution: We can't use result.equalsByGraphElementIds because it internally uses a cross join
    // with equality of elements, which means, it ignores elements that are not within the other dataset
    // This means, the test would succeed even though we have too many vertices as a result of the
    // subgraph operator.
    org.junit.Assert.assertEquals(3, sourceGraph.apply(new ApplySubgraph<>(null, edge -> edge.getPropertyValue("difference").getInt() == 0, Subgraph.Strategy.EDGE_INDUCED)).getVertices().collect().size());
}