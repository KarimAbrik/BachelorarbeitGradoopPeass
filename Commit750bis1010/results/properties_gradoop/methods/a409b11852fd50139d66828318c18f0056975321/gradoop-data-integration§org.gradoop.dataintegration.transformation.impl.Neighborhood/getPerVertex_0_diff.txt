/**
 * This methods returns a {@link DataSet} containing a tuple where the first part is a vertex
 * and the second one a list of all neighbors of this vertex. The vertices are derived from the
 * centralVertices DataSet while the List elements are taken from the graph.
 *
 * @param graph A Graph the operation is executed on.
 * @param centralVertices The vertices the neighborhood should be calculated for.
 * @param edgeDirection The relevant direction for neighbors.
 * @return A Dataset of tuples containing vertices and their neighborhood.
 * @throws NullPointerException if any of the parameters is null.
 */
public static DataSet<Tuple2<EPGMVertex, List<NeighborhoodVertex>>> getPerVertex(LogicalGraph graph, DataSet<EPGMVertex> centralVertices, EdgeDirection edgeDirection) {
    Objects.requireNonNull(graph);
    Objects.requireNonNull(centralVertices);
    Objects.requireNonNull(edgeDirection);
    DataSet<Tuple2<EPGMVertex, List<NeighborhoodVertex>>> incoming = null;
    DataSet<Tuple2<EPGMVertex, List<NeighborhoodVertex>>> outgoing = null;
    // get incoming
    if (edgeDirection.equals(EdgeDirection.INCOMING) || edgeDirection.equals(EdgeDirection.UNDIRECTED)) {
        incoming = graph.getEdges().coGroup(centralVertices).where(new TargetId<>()).equalTo(new Id<>()).with(new CreateNeighborList(edgeDirection));
    }
    // get outgoing
    if (edgeDirection.equals(EdgeDirection.OUTGOING) || edgeDirection.equals(EdgeDirection.UNDIRECTED)) {
        outgoing = graph.getEdges().coGroup(centralVertices).where(new SourceId<>()).equalTo(new Id<>()).with(new CreateNeighborList(edgeDirection));
    }
    if (edgeDirection.equals(EdgeDirection.UNDIRECTED)) {
        return incoming.union(outgoing);
    }
    return edgeDirection.equals(EdgeDirection.INCOMING) ? incoming : outgoing;
}