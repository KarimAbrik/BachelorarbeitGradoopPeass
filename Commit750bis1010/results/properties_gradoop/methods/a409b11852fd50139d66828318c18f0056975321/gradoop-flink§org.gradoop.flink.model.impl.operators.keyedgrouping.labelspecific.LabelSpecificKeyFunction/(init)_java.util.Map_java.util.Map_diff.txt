/**
 * Create an instance of this key function.
 *
 * @param labelsWithKeys    A map assigning a list of key functions to each label.
 * @param labelToSuperLabel A map assigning a label to be set on the super element for each label.
 */
public LabelSpecificKeyFunction(Map<String, List<KeyFunctionWithDefaultValue<T, ?>>> labelsWithKeys, Map<String, String> labelToSuperLabel) {
    final boolean hasDefaultVertexGroup = labelsWithKeys.containsKey(Grouping.DEFAULT_VERTEX_LABEL_GROUP);
    final boolean hasDefaultEdgeGroup = labelsWithKeys.containsKey(Grouping.DEFAULT_EDGE_LABEL_GROUP);
    final String defaultGroupLabel;
    if (hasDefaultEdgeGroup && hasDefaultVertexGroup) {
        throw new IllegalArgumentException("The map contains both default label groups. Only one is expected.");
    } else if (hasDefaultVertexGroup) {
        defaultGroupLabel = Grouping.DEFAULT_VERTEX_LABEL_GROUP;
    } else if (hasDefaultEdgeGroup) {
        defaultGroupLabel = Grouping.DEFAULT_EDGE_LABEL_GROUP;
    } else {
        throw new IllegalArgumentException("The map contains no default label groups. One is expected.");
    }
    final int totalLabels = Objects.requireNonNull(labelsWithKeys).size();
    if (totalLabels + 1 > Tuple.MAX_ARITY) {
        throw new IllegalArgumentException("Too many labels. Tuple arity exceeded: " + (totalLabels + 1) + " (max.: " + Tuple.MAX_ARITY + ")");
    }
    int labelNr = 1;
    labelToIndex = new HashMap<>();
    // The list needs to be filled initially, the set(int,Object) function will fail otherwise.
    keyFunctions = new ArrayList<>(Collections.nCopies(totalLabels, null));
    targetLabels = new String[totalLabels];
    for (Map.Entry<String, List<KeyFunctionWithDefaultValue<T, ?>>> labelToKeys : labelsWithKeys.entrySet()) {
        final String key = labelToKeys.getKey();
        final List<KeyFunctionWithDefaultValue<T, ?>> keysForLabel = labelToKeys.getValue();
        if (key.equals(defaultGroupLabel)) {
            // Ensure that the keys for the default group are always the 0th position.
            keyFunctions.set(0, keysForLabel.size() == 1 ? keysForLabel.get(0) : new CompositeKeyFunctionWithDefaultValues<>(keysForLabel));
            continue;
        }
        labelToIndex.put(key, labelNr);
        targetLabels[labelNr] = key;
        keyFunctions.set(labelNr, keysForLabel.size() == 1 ? keysForLabel.get(0) : new CompositeKeyFunctionWithDefaultValues<>(keysForLabel));
        labelNr++;
    }
    if (labelToSuperLabel != null) {
        for (Map.Entry<String, String> labelUpdateEntry : labelToSuperLabel.entrySet()) {
            Integer index = labelToIndex.get(labelUpdateEntry.getKey());
            if (index == null) {
                continue;
            }
            targetLabels[index] = labelUpdateEntry.getValue();
        }
    }
    reuseTuple = Tuple.newInstance(1 + totalLabels);
}