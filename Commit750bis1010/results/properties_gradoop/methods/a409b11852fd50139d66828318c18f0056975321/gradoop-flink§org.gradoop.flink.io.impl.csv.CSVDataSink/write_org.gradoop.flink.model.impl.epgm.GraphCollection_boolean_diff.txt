@Override
public void write(GraphCollection graphCollection, boolean overwrite) throws IOException {
    FileSystem.WriteMode writeMode = overwrite ? FileSystem.WriteMode.OVERWRITE : FileSystem.WriteMode.NO_OVERWRITE;
    DataSet<Tuple3<String, String, String>> metaData;
    CSVMetaDataSource source = new CSVMetaDataSource();
    if (!reuseMetadata()) {
        metaData = source.tuplesFromCollection(graphCollection);
    } else {
        metaData = source.readDistributed(metaDataPath, getConfig());
    }
    DataSet<CSVGraphHead> csvGraphHeads = graphCollection.getGraphHeads().map(new GraphHeadToCSVGraphHead()).withBroadcastSet(metaData, BC_METADATA);
    DataSet<CSVVertex> csvVertices = graphCollection.getVertices().map(new VertexToCSVVertex()).withBroadcastSet(metaData, BC_METADATA);
    DataSet<CSVEdge> csvEdges = graphCollection.getEdges().map(new EdgeToCSVEdge()).withBroadcastSet(metaData, BC_METADATA);
    // Write metadata only if the path is not the same or reuseMetadata is false.
    if (!getMetaDataPath().equals(metaDataPath) || !reuseMetadata()) {
        new CSVMetaDataSink().writeDistributed(getMetaDataPath(), metaData, writeMode);
    }
    csvGraphHeads.writeAsCsv(getGraphHeadCSVPath(), CSVConstants.ROW_DELIMITER, CSVConstants.TOKEN_DELIMITER, writeMode);
    csvVertices.writeAsCsv(getVertexCSVPath(), CSVConstants.ROW_DELIMITER, CSVConstants.TOKEN_DELIMITER, writeMode);
    csvEdges.writeAsCsv(getEdgeCSVPath(), CSVConstants.ROW_DELIMITER, CSVConstants.TOKEN_DELIMITER, writeMode);
}