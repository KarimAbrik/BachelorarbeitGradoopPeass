/**
 * Splits an escaped string while ignoring escaped delimiters. Does not unescape the tokens.
 *
 * @param escapedString escaped string to be split
 * @param delimiter delimiter string
 * @param limit limits the size of the output
 * @return string array with still escaped strings split by the delimiter
 * @throws IllegalArgumentException if the delimiter contains the escape character
 */
public static String[] split(String escapedString, String delimiter, int limit) throws IllegalArgumentException {
    if (delimiter.contains(Character.toString(ESCAPE_CHARACTER))) {
        throw new IllegalArgumentException(String.format("Delimiter must not contain the escape character: '%c'", ESCAPE_CHARACTER));
    }
    if (limit <= 0) {
        limit = escapedString.length() + 1;
    }
    List<String> tokens = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    boolean escaped = false;
    int delimiterIndex = 0;
    for (char c : escapedString.toCharArray()) {
        // parse and match delimiter
        if (!escaped && c == delimiter.charAt(delimiterIndex)) {
            delimiterIndex++;
            if (delimiterIndex == delimiter.length()) {
                if (tokens.size() < limit - 1) {
                    tokens.add(sb.toString());
                    sb.setLength(0);
                } else {
                    sb.append(delimiter, 0, delimiterIndex);
                }
                delimiterIndex = 0;
            }
        } else {
            // reset delimiter parsing
            sb.append(delimiter, 0, delimiterIndex);
            delimiterIndex = 0;
            // escape
            if (escaped) {
                escaped = false;
            } else if (c == ESCAPE_CHARACTER) {
                escaped = true;
            }
            sb.append(c);
        }
    }
    sb.append(delimiter, 0, delimiterIndex);
    tokens.add(sb.toString());
    return tokens.toArray(new String[0]);
}